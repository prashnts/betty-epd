import pandas as pd

from pprint import pformat
from pydash import py_

from . import consts


class LogicData:
  '''Load, parse, and resolve logic data'''
  def __init__(self, df: pd.DataFrame):
    # initialising class expects a dataframe with columns `t` and `data`.
    # The decoded values may be prefixed with `MOSI:`.

    self._df = df
    self.df = self._decode(df)

  def _decode(self, encoded: pd.DataFrame) -> pd.DataFrame:
    '''Parse logic data and decode values with commands.'''
    df = encoded.copy()

    # Clean the prefixes.
    df['data'] = df.data.str.replace('MOSI: ', '')

    # Parse command bits and resolve them to defined values
    df['flag'] = df.data.str.startswith('0x1')
    df['cmd'] = df.data.apply(lambda x: consts.cmds.get(x, ''))

    # Parse the data/command directive bits.
    df['v_data'] = df.data.str.replace('0x1', '').apply(lambda x: int(x, 16))

    return df

  @classmethod
  def from_csv(cls, fname: str) -> 'LogicData':
    '''Load Logic Analyser data as pandas dataframe.'''
    df = pd.read_csv(fname, header=0, names=['t', 'data'], usecols=[0, 2])
    return LogicData(df)


# def get_lut(seq):

lut_sizes = {
  'LUT_KWVCOM': 32,
  'LUT_KW': 512,
  'LUT_FT': 128,
}


def get_luts(seq):
  luts = {}

  for k, size in lut_sizes.items():
    # grab first index of the lut table
    start = seq.query(f'cmd == "{k}"').index[0] + 1
    end = start + size

    # slice the sequence between these indices and fill in the hashtable
    luts[k] = seq[start:end].v_data.values
  return luts

def gen_header_luts(luts):
  # Serialize the LUTs
  s_lut = (py_(luts)
    .map_values(lambda x: [f'{byte:02x}' for byte in x])
    .map_values(lambda x: pformat(x, compact=True, indent=2))
    .map_values(lambda x: x.replace('[', ' ').replace(']', ','))
    .map_values(lambda x: x.replace('\',', ',').replace('\'', '0x'))

    .value())

  header_fmt = [
    '#ifndef __LUTS_H__',
    '#define __LUTS_H__',
    '// AUTOGENERATED! Dont bother editing this.\n',

    'unsigned short C_LUT_KW_VCOM[] = {{\n{}\n}};\n'.format(s_lut['LUT_KWVCOM']),
    'unsigned short C_LUT_KW[] = {{\n{}\n}};\n'.format(s_lut['LUT_KW']),
    'unsigned short C_LUT_FT[] = {{\n{}\n}};\n'.format(s_lut['LUT_FT']),

    '#endif'
  ]
  return '\n'.join(header_fmt)
